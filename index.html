<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <title>Jednoduchý 3D FPV raycaster</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #222;
    }
  </style>
</head>
<body>
<canvas id="screen" width="800" height="450" onclick="this.requestPointerLock()"></canvas>

<script>
const canvas = document.getElementById("screen");
const ctx = canvas.getContext("2d");

const W = canvas.width;
const H = canvas.height;

// --- MAPA -----------------------------------------------------

const map = [
  [1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1]
];

const mapW = map[0].length;
const mapH = map.length;

// --- HRÁČ -----------------------------------------------------

let px = 3.5;
let py = 3.5;
let pa = 0;

// --- NPC -----------------------------------------------------
let npc = {
  x: 5.5,
  y: 5.5,
  dir: 1,
  speed: 0.02
};


const fov = Math.PI / 3;
const moveSpeed = 0.06;
const rotSpeed = 0.04;
const mouseSensitivity = 0.0025;

// --- OVLÁDÁNÍ -------------------------------------------------

const keys = {};

document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

// Myš – otáčení
document.addEventListener("mousemove", e => {
  if (document.pointerLockElement === canvas) {
    pa += e.movementX * mouseSensitivity;
  }
});

// Kliknutí pro pointer lock
canvas.addEventListener("click", () => {
  canvas.requestPointerLock();
});

// --- FUNKCE ---------------------------------------------------

function isWall(x, y) {
  const mx = Math.floor(x);
  const my = Math.floor(y);
  if (mx < 0 || my < 0 || mx >= mapW || my >= mapH) return true;
  return map[my][mx] === 1;
}

function tryMove(nx, ny) {
  if (!isWall(nx, py)) px = nx;
  if (!isWall(px, ny)) py = ny;
}

function update() {
  // Rotace šipkami
  if (keys["arrowleft"])  pa -= rotSpeed;
  if (keys["arrowright"]) pa += rotSpeed;

  // Vektory pohybu
  let dx = Math.cos(pa) * moveSpeed;
  let dy = Math.sin(pa) * moveSpeed;

  let sdx = Math.cos(pa - Math.PI/2) * moveSpeed;
  let sdy = Math.sin(pa - Math.PI/2) * moveSpeed;

  // WASD
  if (keys["w"]) tryMove(px + dx, py + dy);
  if (keys["s"]) tryMove(px - dx, py - dy);
  if (keys["a"]) tryMove(px + sdx, py + sdy);
  if (keys["d"]) tryMove(px - sdx, py - sdy);

  // Šipky nahoru/dolů
  if (keys["arrowup"])   tryMove(px + dx, py + dy);
  if (keys["arrowdown"]) tryMove(px - dx, py - dy);
  
    // --- NPC pohyb ---
  npc.x += npc.dir * npc.speed;

  if (isWall(npc.x, npc.y)) {
    npc.dir *= -1;
    npc.x += npc.dir * npc.speed;
  }

}

function render() {
  ctx.fillStyle = "#222";
  ctx.fillRect(0, 0, W, H);

  // Obloha
  ctx.fillStyle = "#202040";
  ctx.fillRect(0, 0, W, H / 2);

  // Podlaha
  ctx.fillStyle = "#303020";
  ctx.fillRect(0, H / 2, W, H / 2);

  // Raycasting
  for (let x = 0; x < W; x++) {
    const rayAngle = pa - fov / 2 + (x / W) * fov;
	
	    // --- Ray hit NPC? ---
    const npcDist = Math.hypot(npc.x - px, npc.y - py);
    const npcAngle = Math.atan2(npc.y - py, npc.x - px);
    const diff = Math.abs(((rayAngle - npcAngle + Math.PI*3) % (Math.PI*2)) - Math.PI);

    if (diff < 0.02 && npcDist < 20) {
      const corrected = npcDist * Math.cos(rayAngle - pa);
      const size = Math.min(H, (1 / corrected) * 200);
      const y = (H / 2) - size / 2;

      ctx.fillStyle = "yellow";
      ctx.fillRect(x, y, 1, size);

      continue;
    }


    let dist = 0;
    const step = 0.02;
    let hit = false;

    let rx = px;
    let ry = py;

    while (!hit && dist < 20) {
      dist += step;
      rx = px + Math.cos(rayAngle) * dist;
      ry = py + Math.sin(rayAngle) * dist;
      if (isWall(rx, ry)) hit = true;
    }

    if (hit) {
      const correctedDist = dist * Math.cos(rayAngle - pa);
      const wallHeight = Math.min(H, (1 / correctedDist) * 300);

      const shade = Math.max(50, 255 - correctedDist * 40);
      ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;

      const y = (H / 2) - wallHeight / 2;
      ctx.fillRect(x, y, 1, wallHeight);
    }
  }
}

function loop() {
  update();
  render();
  requestAnimationFrame(loop);
}

loop();
</script>

</body>
</html>
